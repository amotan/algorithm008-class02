## 学习笔记

#### 一、HashMap小总结

##### 1.1 put方法（JDK1.8）
1. 计算 key 的 hash 值。计算方式是 (key == null) ？ 0 ： (h = key.hashCode()) ^ (h >>> 16);
2. 检查当前数组是否为空，为空需要进行初始化，初始化容量是 16 ，负载因子默认 0.75。
3. 计算 key 在数组中的坐标。计算方式：(容量 - 1) & hash.因为容量总是2的次方，所以-1的值的二进制总是全1。方便与 hash 值进行与运算。
4. 如果计算出的坐标元素为空，创建节点加入，put 结束。
5. 如果当前数组容量大于负载因子设置的容量，进行扩容。
	* 如果计算出的坐标元素有值。如果 next 节点为空，把要加入的值和 key 加入 next 节点。
	
* 如果 next 节点不为空，循环查看 next 节点。如果发现有 next 节点的 key 和要加入的 key 一样，对应的值替换为新值。

* 如果循环 next 节点查找超过8层还不为空，把这个位置元素转换为红黑树。

* 如果坐标上的元素值和要加入的值 key 完全一样，覆盖原有值
	
	* 如果坐标上的元素是红黑树，把要加入的值和 key 加入到红黑树。
	
	* 如果坐标上的元素和要加入的元素不同（尾插法增加）。
	
##### 1.2 get方法（JDK1.8）
1. 计算 key 的 hash 值。
2. 如果存储数组不为空，且计算得到的位置上的元素不为空。继续，否则，返回 Null。
3. 如果获取到的元素的 key 值相等，说明查找到了，返回元素。
4. 如果获取到的元素的 key 值不相等，查找 next 节点的元素。
	* 如果元素是红黑树，在红黑树中查找。
	* 不是红黑树，遍历 next 节点查找，找到则返回。

##### 1.3 JDK1.7与JDK1.8的不同实现
1. 内部类
	* 1.7：Entry
	* 1.8：Node
2. Hash计算
  * 1.7：h^=(h>>>20)^(h>>>12);return  h^(h>>>7)^(h>>>4);
  * 1.8：(key==null)?0:(h=key.hashCode())^(h>>>16)
3. 扩容方式
  * 1.7：传入一个新的更大的容量，并以此创建一个新的Entry数组，然后重新计算hash值将原来的数组元素，拷贝到新的Entry数组中。
  * 1.8：扩容时将长度变为原来的2倍newCap = oldCap << 1；重新拷贝数组元素时，key<oldTable.length,元素位置不变，如果key > oldTable.length, 元素位置为原来的索引+oldTable.length;
4. 数据结构
   * 1.7：数组＋链表
   * 1.8：数组＋链表＋红黑树，当链表的长度大于8的时候，后面的数据结构转化为红黑树。



#### 二、算法知识小总结
1. 为什么要用递归来遍历树的节点。
		
		* 因为树的定义没有所谓的后继的结构，或者说一个便于循环的结构，更多的是左节点和右节点。访问子树的话，经常更好的一种方式直接对它的左节点调用相同的遍历函数。
		
2. 树的三种遍历方式：

   * 前序遍历：根-左-右
   * 中序遍历：左-根-右
   * 后序遍历：左-右-根

3. 补充了堆的知识

   

   